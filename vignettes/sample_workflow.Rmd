---
title: "Cleaning, transforming, and normalizing data from image-based screens"
author: "Shantanu Singh"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

This vignette shows a proposed workflow of using cytominr to process 
data from a typical high-thoughput imaging experiment. It is assumed that 
[CellProfiler](http://cellprofiler.org) is used to process the images, and 
the [ExportToSpreadsheet](http://cellprofiler.org/CPmanual/ExportToSpreadsheet.html) 
module is used to output the measurements. 

## Data layout

Consider a sample dataset with this structure

```text
plate_1/process_1/image.csv
plate_1/process_1/object.csv
plate_1/process_2/image.csv
plate_1/process_2/object.csv
...
plate_1/process_35/image.csv
plate_1/process_36/object.csv
```

Here, the wells are arbitrarily divided into 36 groups and each group has a 
per-image and per-object csv file.

A configuration file has details about the dataset

```text
plate_1/config.json
```

```config.json``` will have the listing of csv files, and other details
specifying which columns correspond to metadata, etc.


## Retrieve data 

The csv files are loaded into an SQLite file

```python
create_db("plate_1/config.json")
```

This creates a single, large SQLite file per plate (typically 100-400 million measurements)

```text
plate_1/backend.sqlite
```

## Load data

Load the data (lazy loading) 

```{r, eval=FALSE, echo=TRUE}
D <- cytominr::load("plate_1/backend.sqlite")
```

## Clean data

Filter out invalid cells 

```{r, eval=FALSE, echo=TRUE}
# query_str specifies cells that have NA/Inf in all features
query_str <- D %>% cytominr::form_query("sample_cells",
                                        "invalid")
D %<>% cytominr::filter(query_str)
```

Filter out bad wells using image QC metrics

```{r, eval=FALSE, echo=TRUE}
# query_str specifies images that didnt pass QC metrics
query_str <- D %>% cytominr::form_query("sample_images",
                                        "qcfail")
D %<>% cytominr::filter(query_str)
```

## Normalize features 

Normalize cell features by z-scoring with respect to a reference
distribution (in this case, a random sampling of cells from the plate,
but could instead be from a subset of wells, e.g., only control wells)

```{r, eval=FALSE, echo=TRUE}
# query_str_1 specifies a random sampling of cells 
query_str_1 <- D %>% cytominr::form_query("sample_cells", 
                                          "all",
                                          "random")

# query_str_2 specifies how to calculate normalization parameters
query_str_2 <- D %>% cytominr::form_query("calc_normalization_params", 
                                          "robust_z",
                                          query_str_1)
# D_norm has the normalization parameters per feature
D_norm <- D %>% cytominr::summarize(query_str_2)

# Use D_norm to normalize the data (in this case, subtract the median
# and divide by m.a.d.)
D %<>% cytominr::sweep(D_norm)

# Report features that can't be normalized because of near-zero variance
D_norm %>% 
  cytominr::nzv() %>%
  readr::write_csv("plate_1/nzv.csv")
```

If the reference distribution is to be computed across multiple
plates, we will likely first construct a view to combine the datasets.

## Transform features

Transform features so that their distributions are standard - e.g. Gaussian

```{r, eval=FALSE, echo=TRUE}
# query_str specifies transformation
query_str <- D %>% cytominr::form_query("tranform", 
                                        "generalized_log")
D %<>% cytominr::update(query_str)
```

## Correct for plate effect 

Test whether there is a plate effect and can be corrected using median polish.

To qualitatively assess whether there is a plate effect, output heatmap for intensity
features and cell count on a plate layout. 

```{r, eval=FALSE, echo=TRUE}

D %>%
  cytominr::plate_heatmap(feat_type = "intensity") %>%
  ggplot::ggsave("plate_1/plate_heatmap.pdf", .)

```

To quantitively assess whether median polish can correct the effect, test whether the 
correction is smoothly varying. Test this on intensity features and cell count, but 
(likely) apply to all features.

```{r, eval=FALSE, echo=TRUE}

# Test if med.d$overall + outer(med.d$row,med.d$col, "+") is smooth
# Do for each feature a list feat_l
medpol_smoothness <- 
  sapply(feat_l, 
         function(feat){
           D %>%
             cytominr::select_feat(feat) %>%
             cytominr::medpolish() %>%
             cytominr::smoothness() 
         }
  )
```

If the function is smooth, apply medpolish on plate layout for each feature.

```{r, eval=FALSE, echo=TRUE}

# query_str specifies medpolish
query_str <- D %>% cytominr::form_query("tranform", 
                                        "medpolish")
D %<>% cytominr::update(query_str)

```

## Select features

Measure replicate correlation for each feature and use it to prune feature list
(measuring replicate correlation will likely be done after aggregating cells in a well)

```{r, eval=FALSE, echo=TRUE}
# Do for each feature a list feat_l
repcor_l <- 
  sapply(feat_l, 
         function(feat){
           D %>%
             cytominr::select_feat(feat) %>%
             cytominr::repcor(method = "pearson")
         }
  )

feat_good_l <- names(repcor_l[repcor_l > .3])

query_str <- D %>% cytominr::form_query("select_features", 
                                        feat_good_l)

D %<>% 
  cytominr::filter(query_str)

```


Select features by reducing the number of highly correlated features
(measuring feature correlation will likely be done after aggregating cells in a well)

```{r, eval=FALSE, echo=TRUE}

feat_cor_l <- 
  D %>% 
  cytominr::find_correlation() 

query_str <- D %>% cytominr::form_query("select_features", 
                                        feat_cor_l)

D %<>% 
  cytominr::filter(query_str)
  
```


## Save data

```{r, eval=FALSE, echo=TRUE}
D %>%
  cytominr::save()
```
